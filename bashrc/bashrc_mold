alias -- -='cd -'
alias ..='cd ../'
alias ...='cd ../../'
alias ....='cd ../../../'
alias .....='cd ../../../../'
alias ......='cd ../../../../../'
alias .......='cd ../../../../../../'
alias ........='cd ../../../../../../../'
alias .........='cd ../../../../../../../../'
alias ipconfig='ifconfig'
alias sudo='sudo '
alias open="xdg-open 2>/dev/null"
alias npm="bun"
alias npx="bunx"
alias expo='npx expo'

export EDITOR=emacs

mkd() {
	str="$*"
	mkdir -p "$str"
	cd "$str"
}

repo() {
	cd ~/git/"$1"
}

_repo_complete() {
	local cur base_dir
	cur="${COMP_WORDS[1]}"
	base_dir=~/git/

	# Generate a list of subdirectories without the full path
	COMPREPLY=( $(compgen -W "$(find "$base_dir" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)" -- "$cur") )
}

complete -F _repo_complete repo

DaySuffix() {
  case `date +%-d` in
	1|21|31) echo "st";;
	2|22)    echo "nd";;
	3|23)    echo "rd";;
	*)       echo "th";;
  esac
}

date "+  %-l:%M%p - %a %-d`DaySuffix` %b %Y"

export PIP_BREAK_SYSTEM_PACKAGES=1

complete -F _complete_alias i

clone() {
	cd ~/git
	local args src dest
	args=""; src=""; dest=""
	for arg; do
		if [[ $arg =~ ^- ]]; then
			args+=" $arg"
		elif [[ $src == "" ]]; then
			src="$arg"
		elif [[ $dest == "" ]]; then
			dest="$arg"
		else
			echo "ERROR: too many positional arguments."; return 1
		fi
	done
	args=$(echo "$args" | sed 's/^\ *//')
	if [[ $src =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
		src="https://github.com/$src"
	fi
	git clone $args $src $dest
	if [[ ! -z "$dest" ]]; then
		cd "$dest"
	else
		lastarg="$(basename $src)"
		lastarg="${lastarg%.git}"
		cd "$lastarg"
	fi
}

update() {
	UPDATE_LOCK=/var/tmp/updatelock
	if [ -f $UPDATE_LOCK ]; then
		echo "Update command already running! If you believe this to be false, consider removing the $UPDATE_LOCK file."
		while true; do
			read -p "Remove lock file and update anyway? [y/N]: " yn
			case $yn in
				[Nn]*|"" ) return 1;;
				[Yy]* ) rm $UPDATE_LOCK; break;;
			esac
		done
	fi
	touch $UPDATE_LOCK
	
	echo ""
	if [ $# -eq 0 ]; then
		for manager in "${!packageManagers[@]}"; do
			local string="Updating $manager packages…"
			echo " $string"
			for i in $(seq 1 $((${#string} + 2))); do 
				echo -n "‾"
			done
			echo ""
			eval "${packageManagers[$manager]}"
			echo ""
		done
	else
		for input in "$@"; do
			local found=false
			local search=${input,,} 

			for manager in "${!packageManagers[@]}"; do
				if [[ "${manager,,}" == "$search" ]]; then
					local string="Updating $manager packages…"
					echo " $string"
					for i in $(seq 1 $((${#string} + 2))); do 
						echo -n "‾"
					done
					echo ""
					eval "${packageManagers[$manager]}"
					echo ""
					found=true
					break
				fi
			done

			if [ "$found" = false ]; then
				echo "Package manager '$input' not found."
			fi
		done
	fi

	rm $UPDATE_LOCK
	echo " Done!"
	echo "‾‾‾‾‾‾‾"
}
_update_complete() {
	local cur words
	cur=$(printf %s "${COMP_WORDS[COMP_CWORD]}" | tr [:upper:] [:lower:])
	words=$(printf %s "${!packageManagers[*]}" | tr [:upper:] [:lower:])
	
	COMPREPLY=( $(compgen -W "$words" -- "$cur") )
}
complete -F _update_complete update

modify() {
	if [ $# -eq 0 ]; then
		echo "No argument supplied"
		return 1
	elif [[ $# -eq 1 ]]; then
		open $(which "$1")
	else
		"$2" $(which "$1")
	fi
}
_modify_complete() {
	local cur
	cur="${COMP_WORDS[COMP_CWORD]}"
	COMPREPLY=( $(compgen -c -- "$cur") )
}
complete -F _modify_complete modify

source ~/.extra_bashrc
